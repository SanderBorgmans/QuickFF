<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1. quickff.cost – Least-Square cost function for hessian matching &mdash; QuickFF 2.1.3 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.1.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="QuickFF 2.1.3 documentation" href="index.html" />
    <link rel="next" title="1. qff.py – Main script to run QuickFF calculation" href="rg_scripts.html" />
    <link rel="prev" title="Tutorial 3 - Biphenyl" href="tu_biphenyl.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="rg_scripts.html" title="1. qff.py – Main script to run QuickFF calculation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tu_biphenyl.html" title="Tutorial 3 - Biphenyl"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">QuickFF 2.1.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-quickff.cost">
<span id="quickff-cost-least-square-cost-function-for-hessian-matching"></span><h1>1. <tt class="docutils literal"><span class="pre">quickff.cost</span></tt> &#8211; Least-Square cost function for hessian matching<a class="headerlink" href="#module-quickff.cost" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="quickff.cost.HessianFCCost">
<em class="property">class </em><tt class="descclassname">quickff.cost.</tt><tt class="descname">HessianFCCost</tt><big>(</big><em>system</em>, <em>ai</em>, <em>valence</em>, <em>fit_indices</em>, <em>ffrefs=[]</em><big>)</big><a class="reference internal" href="_modules/quickff/cost.html#HessianFCCost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.cost.HessianFCCost" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to implement the least-square cost function to fit the force
field hessian to the ab initio hessian.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>a Yaff system object</dd>
<dt>ai</dt>
<dd>an instance of the Reference representing the ab initio input</dd>
<dt>valence</dt>
<dd>A ValenceFF object containing all valence terms.</dd>
<dt>fit_indices</dt>
<dd>a list of indices indicating the terms for which the force
constants should be determined.</dd>
</dl>
<p><strong>Optional Arguments</strong></p>
<dl class="docutils">
<dt>ffrefs</dt>
<dd>a list of Reference instances representing possible a priori
determined contributions to the force field (such as eg.
electrostatics and van der Waals)</dd>
</dl>
<dl class="method">
<dt id="quickff.cost.HessianFCCost.estimate">
<tt class="descname">estimate</tt><big>(</big><em>init=None</em>, <em>lower=None</em>, <em>upper=None</em><big>)</big><a class="reference internal" href="_modules/quickff/cost.html#HessianFCCost.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.cost.HessianFCCost.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the force constants by minimizing the cost function</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-quickff.io">
<span id="quickff-io-input-ouput-methods"></span><h1>2. <tt class="docutils literal"><span class="pre">quickff.io</span></tt> &#8211; Input/Ouput methods<a class="headerlink" href="#module-quickff.io" title="Permalink to this headline">¶</a></h1>
<p>Readers ab initio vibrational calculations.</p>
<dl class="class">
<dt id="quickff.io.VASPRun">
<em class="property">class </em><tt class="descclassname">quickff.io.</tt><tt class="descname">VASPRun</tt><big>(</big><em>filename</em>, <em>field_labels=[]</em><big>)</big><a class="reference internal" href="_modules/quickff/io.html#VASPRun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.io.VASPRun" title="Permalink to this definition">¶</a></dt>
<dd><p>Load information from a vasprun.xml file</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>filename</dt>
<dd>Filename of vasprun.xml</dd>
</dl>
<p><strong>Optional Arguments</strong></p>
<dl class="docutils">
<dt>field_labels</dt>
<dd>List of things we want to read. If an empty list is provided,
only numbers, masses, initial positions and initial cell
vectors are read.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="quickff.io.read_abinitio">
<tt class="descclassname">quickff.io.</tt><tt class="descname">read_abinitio</tt><big>(</big><em>fn</em>, <em>do_hess=True</em><big>)</big><a class="reference internal" href="_modules/quickff/io.html#read_abinitio"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.io.read_abinitio" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to read all information from an ab initio calculation that
QuickFF needs. Currently Gaussian .fchk and VASP .xml files are
supported.</p>
<p><strong>Optional Arguments</strong></p>
<dl class="docutils">
<dt>do_hess</dt>
<dd>Extract the hessian from the ab initio output. For qff-input-ei.py,
it is interesting to be able to switch this off.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="quickff.io.dump_charmm22_prm">
<tt class="descclassname">quickff.io.</tt><tt class="descname">dump_charmm22_prm</tt><big>(</big><em>valence</em>, <em>fn</em><big>)</big><a class="reference internal" href="_modules/quickff/io.html#dump_charmm22_prm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.io.dump_charmm22_prm" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump supported parameters in a CHARMM22 parameter file.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>valence</dt>
<dd>Instance of ValenceFF, which defines the force field.</dd>
<dt>fn</dt>
<dd>The filename to write to.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="quickff.io.dump_charmm22_psf">
<tt class="descclassname">quickff.io.</tt><tt class="descname">dump_charmm22_psf</tt><big>(</big><em>system</em>, <em>valence</em>, <em>fn</em><big>)</big><a class="reference internal" href="_modules/quickff/io.html#dump_charmm22_psf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.io.dump_charmm22_psf" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump supported internal coordinates in a CHARMM psf file.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>Instance of yaff.System class</dd>
<dt>valence</dt>
<dd>Instance of ValenceFF, which defines the force field.</dd>
<dt>fn</dt>
<dd>The filename to write to.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-quickff.perturbation">
<span id="quickff-perturbation-perturbation-trajectories-for-internal-coordinates"></span><h1>3. <tt class="docutils literal"><span class="pre">quickff.perturbation</span></tt> &#8211; Perturbation trajectories for internal coordinates<a class="headerlink" href="#module-quickff.perturbation" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="quickff.perturbation.Trajectory">
<em class="property">class </em><tt class="descclassname">quickff.perturbation.</tt><tt class="descname">Trajectory</tt><big>(</big><em>term</em>, <em>start</em>, <em>end</em>, <em>numbers</em>, <em>steps=11</em><big>)</big><a class="reference internal" href="_modules/quickff/perturbation.html#Trajectory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.perturbation.Trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to store a perturbation trajectory</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>term</dt>
<dd>an instance of the Term class for which the perturbation
trajectory will be computed</dd>
<dt>numbers</dt>
<dd>list of atom numbers required for dumping xyz coords</dd>
<dt>start</dt>
<dd>a float defining the lower limit of the perturbation value of
the given ic. If not given, a standard value is choosen
according to the kind of internal coordinate.</dd>
<dt>end</dt>
<dd>a float defining the upper limit of the perturbations value of
the given ic. If not given, a standard value is choosen
according to the kind of internal coordinate.</dd>
</dl>
<p><strong>Optional Arguments</strong></p>
<dl class="docutils">
<dt>steps</dt>
<dd>an integer defining the number of steps in the perturbation
trajectory. The default value is 11 steps.</dd>
</dl>
<dl class="method">
<dt id="quickff.perturbation.Trajectory.plot">
<tt class="descname">plot</tt><big>(</big><em>ai</em>, <em>ffrefs=[]</em>, <em>valence=None</em>, <em>fn=None</em>, <em>eunit='kjmol'</em><big>)</big><a class="reference internal" href="_modules/quickff/perturbation.html#Trajectory.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.perturbation.Trajectory.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to plot the energy contributions along a perturbation
trajectory associated to a given ic. This method assumes that the
coords, fc and rv attributes have been computed and assigned.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>ai</dt>
<dd>an instance of the Reference representing the ab initio input</dd>
</dl>
<p><strong>Optional Arguments</strong></p>
<dl class="docutils">
<dt>ffrefs</dt>
<dd>a list of Reference instances representing possible a priori
determined contributions to the force field (such as eg.
electrostatics and van der Waals)</dd>
<dt>valence</dt>
<dd>an instance of ValenceFF which will be used to plot the covalent
contribution. If not given, only the contribution of the IC
corresponding to the trajectory will be plotted using the values
of fc and rv</dd>
<dt>fn</dt>
<dd>a string defining the name of the figure</dd>
<dt>eunit</dt>
<dd>a string describing the conversion of the unit of energy. More
info regarding possible strings can be found in the
<a class="reference external" href="http://molmod.github.io/molmod/reference/const.html#module-molmod.units">MolMod documentation</a>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quickff.perturbation.Trajectory.to_xyz">
<tt class="descname">to_xyz</tt><big>(</big><em>fn=None</em><big>)</big><a class="reference internal" href="_modules/quickff/perturbation.html#Trajectory.to_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.perturbation.Trajectory.to_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to write the given trajectory to an XYZ file. This method
assumes that the coords attribute has been assigned.</p>
<p><strong>Optional Arguments</strong></p>
<dl class="docutils">
<dt>fn</dt>
<dd>a string defining the name of the output file</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-quickff.program">
<span id="quickff-program-program-classes-implementing-a-sequence-of-fitting-steps"></span><span id="seclab-rg-modules-program"></span><h1>4. <tt class="docutils literal"><span class="pre">quickff.program</span></tt> &#8211; Program classes implementing a sequence of fitting steps<a class="headerlink" href="#module-quickff.program" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="quickff.program.BaseProgram">
<em class="property">class </em><tt class="descclassname">quickff.program.</tt><tt class="descname">BaseProgram</tt><big>(</big><em>system</em>, <em>ai</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Base program which implements all possible steps of a force field
fitting program. The actual sequence of the steps are defined in the
deriving classes.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>a Yaff <cite>System</cite> object defining the system</dd>
<dt>ai</dt>
<dd>a <cite>Reference</cite> instance corresponding to the ab initio input data</dd>
</dl>
<p><strong>Keyword Arguments</strong></p>
<dl class="docutils">
<dt>ffrefs</dt>
<dd>a list of <cite>Reference</cite> objects corresponding to a priori determined
contributions to the force field (such as eg. electrostatics
or van der Waals contributions)</dd>
<dt>fn_yaff</dt>
<dd>the name of the file to write the final parameters to in Yaff
format. The default is <cite>pars.txt</cite>.</dd>
<dt>fn_charmm22_prm</dt>
<dd>the name of a CHARMM parameter file. If not given, the file is not written</dd>
<dt>fn_charmm22_psf</dt>
<dd>the name of a CHARMM topology file. If not given, the file is not written</dd>
<dt>fn_sys</dt>
<dd>the name of the file to write the system to. The default is
<cite>system.chk</cite>.</dd>
<dt>fn_traj</dt>
<dd>a cPickle filename to read/write the perturbation trajectories
from/to. If the file exists, the trajectories are read from the
file. If the file does not exist, the trajectories are written
to the file.</dd>
<dt>only_traj</dt>
<dd>specifier to determine for which terms a perturbation trajectory
needs to be constructed. If ONLY_TRAJ is a single string, it is
interpreted as a task (only terms that have this task in their
tasks attribute will get a trajectory). If ONLY_TRAJ is a list
of strings, each string is interpreted as the basename of the
term for which a trajectory will be constructed.</dd>
<dt>plot_traj</dt>
<dd>if set to True, all energy contributions along each perturbation
trajectory will be plotted using the final force field.</dd>
<dt>xyz_traj</dt>
<dd>if set to True, each perturbation trajectory will be written to
an XYZ file.</dd>
</dl>
<dl class="method">
<dt id="quickff.program.BaseProgram.average_pars">
<tt class="descname">average_pars</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.average_pars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.average_pars" title="Permalink to this definition">¶</a></dt>
<dd><p>Average force field parameters over master and slaves.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.do_bendcharm">
<tt class="descname">do_bendcharm</tt><big>(</big><em>thresshold=0.03490658503988659</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.do_bendcharm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.do_bendcharm" title="Permalink to this definition">¶</a></dt>
<dd><p>No Harmonic bend can have a rest value equal to are large than
180 deg - thresshold. If a master (or its slaves) has such a rest
value, convert master and all slaves to BendCharm with
cos(phis0)=-1.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.do_cross_init">
<tt class="descname">do_cross_init</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.do_cross_init"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.do_cross_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the rest values of cross terms to the rest values of the
corresponding diagonal terms. The force constants are initialized
to zero.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.do_eq_setrv">
<tt class="descname">do_eq_setrv</tt><big>(</big><em>tasks</em>, <em>logger_level=3</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.do_eq_setrv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.do_eq_setrv" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the rest values to their respective AI equilibrium values.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.do_hc_estimatefc">
<tt class="descname">do_hc_estimatefc</tt><big>(</big><em>tasks</em>, <em>logger_level=3</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.do_hc_estimatefc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.do_hc_estimatefc" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine force constants using Hessian Cost function.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>tasks</dt>
<dd>A list of strings identifying which terms should have their
force constant estimated from the hessian cost function. Using
such a flag, one can distinguish between for example force
constant refinement (flag=HC_FC_DIAG) of the diagonal terms and
force constant estimation of the cross terms (flag=HC_FC_CROSS).
If the string &#8216;all&#8217; is present in tasks, all fc&#8217;s will be
estimated.</dd>
</dl>
<p><strong>Optional Arguments</strong></p>
<dl class="docutils">
<dt>logger_level</dt>
<dd>print level at which the resulting parameters should be dumped to
the logger. By default, the parameters will only be dumped at
the highest log level.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.do_pt_estimate">
<tt class="descname">do_pt_estimate</tt><big>(</big><em>do_valence=False</em>, <em>logger_level=3</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.do_pt_estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.do_pt_estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate force constants and rest values from the perturbation
trajectories</p>
<p><strong>Optional Arguments</strong></p>
<dl class="docutils">
<dt>do_valence</dt>
<dd>if set to True, the current valence force field will be used to
estimate the contribution of all other valence terms.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.do_pt_generate">
<tt class="descname">do_pt_generate</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.do_pt_generate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.do_pt_generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate perturbation trajectories.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.do_pt_postprocess">
<tt class="descname">do_pt_postprocess</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.do_pt_postprocess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.do_pt_postprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Do some first post processing of the ff parameters estimated from
the perturbation trajectories including:</p>
<blockquote>
<div><ul class="simple">
<li>detecting bend patterns with rest values of 90 and 180 deg</li>
<li>detecting bend patterns with rest values only close to 180 deg</li>
<li>averaging parameters</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.do_sqoopdist_to_oopdist">
<tt class="descname">do_sqoopdist_to_oopdist</tt><big>(</big><em>thresshold=0.0001889726133921252</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.do_sqoopdist_to_oopdist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.do_sqoopdist_to_oopdist" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a SqOopdist term with a rest value that has been set to
zero, to a term Oopdist (harmonic in Oopdist instead of square of
Oopdist) with a rest value of 0.0 A.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.do_squarebend">
<tt class="descname">do_squarebend</tt><big>(</big><em>thresshold=0.17453292519943295</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.do_squarebend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.do_squarebend" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify bend patterns in which 4 atoms of type A surround a central
atom of type B with A-B-A angles of 90/180 degrees. A simple
harmonic pattern will not be adequate since a rest value of 90 and
180 degrees is possible for the same A-B-A term. Therefore, a
cosine term with multiplicity of 4 is used:</p>
<blockquote>
<div>V = K/2*[1-cos(4*theta)]</div></blockquote>
<p>To identify the patterns, it is assumed that the rest values have
already been estimated from the perturbation trajectories. For each
master and slave of a BENDAHARM term, its rest value is computed and
checked if it lies either the interval [90-thresshold,90+thresshold]
or [180-thresshold,180]. If this is the case, the new cosine term
is used.</p>
<p><strong>Optional arguments</strong></p>
<dl class="docutils">
<dt>thresshold</dt>
<dd>the (half) the width of the interval around 180 deg (90 degrees)
to check if a square BA4</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.make_output">
<tt class="descname">make_output</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.make_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.make_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump Yaff parameters, Yaff system, plot energy contributions along
perturbation trajectories and dump perturbation trajectories to XYZ
files.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.plot_trajectories">
<tt class="descname">plot_trajectories</tt><big>(</big><em>do_valence=False</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.plot_trajectories"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.plot_trajectories" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot energy contributions along perturbation trajectories and dump
perturbation trajectories to XYZ files.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.reset_system">
<tt class="descname">reset_system</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.reset_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.reset_system" title="Permalink to this definition">¶</a></dt>
<dd><p>routine to reset the system coords to the ai equilbrium</p>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Sequence of instructions, should be implemented in the inheriting
classes. The various inheriting classes distinguish themselves by
means of the instructions implemented in this routine.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.program.BaseProgram.update_trajectory_terms">
<tt class="descname">update_trajectory_terms</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quickff/program.html#BaseProgram.update_trajectory_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.BaseProgram.update_trajectory_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to make <tt class="docutils literal"><span class="pre">self.valence.terms</span></tt> and the term attribute of each
trajectory in <tt class="docutils literal"><span class="pre">self.trajectories</span></tt> consistent again. This is usefull
if the trajectory were read from a file and the <tt class="docutils literal"><span class="pre">valenceFF</span></tt> instance
was modified.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="quickff.program.MakeTrajectories">
<em class="property">class </em><tt class="descclassname">quickff.program.</tt><tt class="descname">MakeTrajectories</tt><big>(</big><em>system</em>, <em>ai</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#MakeTrajectories"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.MakeTrajectories" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the perturbation trajectories and store them. This program
does not derive the force field.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>a Yaff <cite>System</cite> object defining the system</dd>
<dt>ai</dt>
<dd>a <cite>Reference</cite> instance corresponding to the ab initio input data</dd>
</dl>
<p><strong>Keyword Arguments</strong></p>
<dl class="docutils">
<dt>ffrefs</dt>
<dd>a list of <cite>Reference</cite> objects corresponding to a priori determined
contributions to the force field (such as eg. electrostatics
or van der Waals contributions)</dd>
<dt>fn_yaff</dt>
<dd>the name of the file to write the final parameters to in Yaff
format. The default is <cite>pars.txt</cite>.</dd>
<dt>fn_charmm22_prm</dt>
<dd>the name of a CHARMM parameter file. If not given, the file is not written</dd>
<dt>fn_charmm22_psf</dt>
<dd>the name of a CHARMM topology file. If not given, the file is not written</dd>
<dt>fn_sys</dt>
<dd>the name of the file to write the system to. The default is
<cite>system.chk</cite>.</dd>
<dt>fn_traj</dt>
<dd>a cPickle filename to read/write the perturbation trajectories
from/to. If the file exists, the trajectories are read from the
file. If the file does not exist, the trajectories are written
to the file.</dd>
<dt>only_traj</dt>
<dd>specifier to determine for which terms a perturbation trajectory
needs to be constructed. If ONLY_TRAJ is a single string, it is
interpreted as a task (only terms that have this task in their
tasks attribute will get a trajectory). If ONLY_TRAJ is a list
of strings, each string is interpreted as the basename of the
term for which a trajectory will be constructed.</dd>
<dt>plot_traj</dt>
<dd>if set to True, all energy contributions along each perturbation
trajectory will be plotted using the final force field.</dd>
<dt>xyz_traj</dt>
<dd>if set to True, each perturbation trajectory will be written to
an XYZ file.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="quickff.program.PlotTrajectories">
<em class="property">class </em><tt class="descclassname">quickff.program.</tt><tt class="descname">PlotTrajectories</tt><big>(</big><em>system</em>, <em>ai</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#PlotTrajectories"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.PlotTrajectories" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the perturbation trajectories, dump to XYZ files and plot the
energy contributions. This program does not derive the force field.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>a Yaff <cite>System</cite> object defining the system</dd>
<dt>ai</dt>
<dd>a <cite>Reference</cite> instance corresponding to the ab initio input data</dd>
</dl>
<p><strong>Keyword Arguments</strong></p>
<dl class="docutils">
<dt>ffrefs</dt>
<dd>a list of <cite>Reference</cite> objects corresponding to a priori determined
contributions to the force field (such as eg. electrostatics
or van der Waals contributions)</dd>
<dt>fn_yaff</dt>
<dd>the name of the file to write the final parameters to in Yaff
format. The default is <cite>pars.txt</cite>.</dd>
<dt>fn_charmm22_prm</dt>
<dd>the name of a CHARMM parameter file. If not given, the file is not written</dd>
<dt>fn_charmm22_psf</dt>
<dd>the name of a CHARMM topology file. If not given, the file is not written</dd>
<dt>fn_sys</dt>
<dd>the name of the file to write the system to. The default is
<cite>system.chk</cite>.</dd>
<dt>fn_traj</dt>
<dd>a cPickle filename to read/write the perturbation trajectories
from/to. If the file exists, the trajectories are read from the
file. If the file does not exist, the trajectories are written
to the file.</dd>
<dt>only_traj</dt>
<dd>specifier to determine for which terms a perturbation trajectory
needs to be constructed. If ONLY_TRAJ is a single string, it is
interpreted as a task (only terms that have this task in their
tasks attribute will get a trajectory). If ONLY_TRAJ is a list
of strings, each string is interpreted as the basename of the
term for which a trajectory will be constructed.</dd>
<dt>plot_traj</dt>
<dd>if set to True, all energy contributions along each perturbation
trajectory will be plotted using the final force field.</dd>
<dt>xyz_traj</dt>
<dd>if set to True, each perturbation trajectory will be written to
an XYZ file.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="quickff.program.DeriveDiagFF">
<em class="property">class </em><tt class="descclassname">quickff.program.</tt><tt class="descname">DeriveDiagFF</tt><big>(</big><em>system</em>, <em>ai</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#DeriveDiagFF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.DeriveDiagFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive a diagonal force field, i.e. without cross terms. After the
hessian fit of the force constants, the rest values are refined by
revisiting the perturbation trajectories with an extra a priori term
representing the present valence contribution. Finally, the force 
constants are refined by means of a final hessian fit.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>a Yaff <cite>System</cite> object defining the system</dd>
<dt>ai</dt>
<dd>a <cite>Reference</cite> instance corresponding to the ab initio input data</dd>
</dl>
<p><strong>Keyword Arguments</strong></p>
<dl class="docutils">
<dt>ffrefs</dt>
<dd>a list of <cite>Reference</cite> objects corresponding to a priori determined
contributions to the force field (such as eg. electrostatics
or van der Waals contributions)</dd>
<dt>fn_yaff</dt>
<dd>the name of the file to write the final parameters to in Yaff
format. The default is <cite>pars.txt</cite>.</dd>
<dt>fn_charmm22_prm</dt>
<dd>the name of a CHARMM parameter file. If not given, the file is not written</dd>
<dt>fn_charmm22_psf</dt>
<dd>the name of a CHARMM topology file. If not given, the file is not written</dd>
<dt>fn_sys</dt>
<dd>the name of the file to write the system to. The default is
<cite>system.chk</cite>.</dd>
<dt>fn_traj</dt>
<dd>a cPickle filename to read/write the perturbation trajectories
from/to. If the file exists, the trajectories are read from the
file. If the file does not exist, the trajectories are written
to the file.</dd>
<dt>only_traj</dt>
<dd>specifier to determine for which terms a perturbation trajectory
needs to be constructed. If ONLY_TRAJ is a single string, it is
interpreted as a task (only terms that have this task in their
tasks attribute will get a trajectory). If ONLY_TRAJ is a list
of strings, each string is interpreted as the basename of the
term for which a trajectory will be constructed.</dd>
<dt>plot_traj</dt>
<dd>if set to True, all energy contributions along each perturbation
trajectory will be plotted using the final force field.</dd>
<dt>xyz_traj</dt>
<dd>if set to True, each perturbation trajectory will be written to
an XYZ file.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="quickff.program.DeriveNonDiagFF">
<em class="property">class </em><tt class="descclassname">quickff.program.</tt><tt class="descname">DeriveNonDiagFF</tt><big>(</big><em>system</em>, <em>ai</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#DeriveNonDiagFF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.DeriveNonDiagFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive a non-diagonal force field, i.e. with cross terms. After the
hessian fit of the force constants, the rest values are refined by
revisiting the perturbation trajectories with an extra a priori term
representing the present valence contribution. Finally, the force 
constants are refined by means of a final hessian fit.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>a Yaff <cite>System</cite> object defining the system</dd>
<dt>ai</dt>
<dd>a <cite>Reference</cite> instance corresponding to the ab initio input data</dd>
</dl>
<p><strong>Keyword Arguments</strong></p>
<dl class="docutils">
<dt>ffrefs</dt>
<dd>a list of <cite>Reference</cite> objects corresponding to a priori determined
contributions to the force field (such as eg. electrostatics
or van der Waals contributions)</dd>
<dt>fn_yaff</dt>
<dd>the name of the file to write the final parameters to in Yaff
format. The default is <cite>pars.txt</cite>.</dd>
<dt>fn_charmm22_prm</dt>
<dd>the name of a CHARMM parameter file. If not given, the file is not written</dd>
<dt>fn_charmm22_psf</dt>
<dd>the name of a CHARMM topology file. If not given, the file is not written</dd>
<dt>fn_sys</dt>
<dd>the name of the file to write the system to. The default is
<cite>system.chk</cite>.</dd>
<dt>fn_traj</dt>
<dd>a cPickle filename to read/write the perturbation trajectories
from/to. If the file exists, the trajectories are read from the
file. If the file does not exist, the trajectories are written
to the file.</dd>
<dt>only_traj</dt>
<dd>specifier to determine for which terms a perturbation trajectory
needs to be constructed. If ONLY_TRAJ is a single string, it is
interpreted as a task (only terms that have this task in their
tasks attribute will get a trajectory). If ONLY_TRAJ is a list
of strings, each string is interpreted as the basename of the
term for which a trajectory will be constructed.</dd>
<dt>plot_traj</dt>
<dd>if set to True, all energy contributions along each perturbation
trajectory will be plotted using the final force field.</dd>
<dt>xyz_traj</dt>
<dd>if set to True, each perturbation trajectory will be written to
an XYZ file.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="quickff.program.DeriveNonDiagFFNoQRef">
<em class="property">class </em><tt class="descclassname">quickff.program.</tt><tt class="descname">DeriveNonDiagFFNoQRef</tt><big>(</big><em>system</em>, <em>ai</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quickff/program.html#DeriveNonDiagFFNoQRef"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.program.DeriveNonDiagFFNoQRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive a non-diagonal force field, i.e. with cross terms, whitout
the refinement of the rest value by revisiting the perturbation
trajectories.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>a Yaff <cite>System</cite> object defining the system</dd>
<dt>ai</dt>
<dd>a <cite>Reference</cite> instance corresponding to the ab initio input data</dd>
</dl>
<p><strong>Keyword Arguments</strong></p>
<dl class="docutils">
<dt>ffrefs</dt>
<dd>a list of <cite>Reference</cite> objects corresponding to a priori determined
contributions to the force field (such as eg. electrostatics
or van der Waals contributions)</dd>
<dt>fn_yaff</dt>
<dd>the name of the file to write the final parameters to in Yaff
format. The default is <cite>pars.txt</cite>.</dd>
<dt>fn_charmm22_prm</dt>
<dd>the name of a CHARMM parameter file. If not given, the file is not written</dd>
<dt>fn_charmm22_psf</dt>
<dd>the name of a CHARMM topology file. If not given, the file is not written</dd>
<dt>fn_sys</dt>
<dd>the name of the file to write the system to. The default is
<cite>system.chk</cite>.</dd>
<dt>fn_traj</dt>
<dd>a cPickle filename to read/write the perturbation trajectories
from/to. If the file exists, the trajectories are read from the
file. If the file does not exist, the trajectories are written
to the file.</dd>
<dt>only_traj</dt>
<dd>specifier to determine for which terms a perturbation trajectory
needs to be constructed. If ONLY_TRAJ is a single string, it is
interpreted as a task (only terms that have this task in their
tasks attribute will get a trajectory). If ONLY_TRAJ is a list
of strings, each string is interpreted as the basename of the
term for which a trajectory will be constructed.</dd>
<dt>plot_traj</dt>
<dd>if set to True, all energy contributions along each perturbation
trajectory will be plotted using the final force field.</dd>
<dt>xyz_traj</dt>
<dd>if set to True, each perturbation trajectory will be written to
an XYZ file.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-quickff.reference">
<span id="quickff-reference-representation-of-the-ab-initio-reference-data"></span><h1>5. <tt class="docutils literal"><span class="pre">quickff.reference</span></tt> &#8211; Representation of the ab initio reference data<a class="headerlink" href="#module-quickff.reference" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="quickff.reference.SecondOrderTaylor">
<em class="property">class </em><tt class="descclassname">quickff.reference.</tt><tt class="descname">SecondOrderTaylor</tt><big>(</big><em>name, coords=None, energy=0.0, grad=None, hess=None, pbc=[0, 0, 0]</em><big>)</big><a class="reference internal" href="_modules/quickff/reference.html#SecondOrderTaylor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.reference.SecondOrderTaylor" title="Permalink to this definition">¶</a></dt>
<dd><p>Second-order Taylor expansion model, can be used for the ab initio input.</p>
<dl class="method">
<dt id="quickff.reference.SecondOrderTaylor.energy">
<tt class="descname">energy</tt><big>(</big><em>coords</em><big>)</big><a class="reference internal" href="_modules/quickff/reference.html#SecondOrderTaylor.energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.reference.SecondOrderTaylor.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the energy for the given positions</p>
</dd></dl>

<dl class="method">
<dt id="quickff.reference.SecondOrderTaylor.gradient">
<tt class="descname">gradient</tt><big>(</big><em>coords</em><big>)</big><a class="reference internal" href="_modules/quickff/reference.html#SecondOrderTaylor.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.reference.SecondOrderTaylor.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gradient for the given positions</p>
</dd></dl>

<dl class="method">
<dt id="quickff.reference.SecondOrderTaylor.hessian">
<tt class="descname">hessian</tt><big>(</big><em>coords</em><big>)</big><a class="reference internal" href="_modules/quickff/reference.html#SecondOrderTaylor.hessian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.reference.SecondOrderTaylor.hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the hessian for the given positions</p>
</dd></dl>

<dl class="method">
<dt id="quickff.reference.SecondOrderTaylor.update">
<tt class="descname">update</tt><big>(</big><em>coords=None</em>, <em>grad=None</em>, <em>hess=None</em>, <em>pbc=None</em><big>)</big><a class="reference internal" href="_modules/quickff/reference.html#SecondOrderTaylor.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.reference.SecondOrderTaylor.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to update one or more of the attributes. The meaning of the
optional arguments is the same as with the constructor __init__</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="quickff.reference.YaffForceField">
<em class="property">class </em><tt class="descclassname">quickff.reference.</tt><tt class="descname">YaffForceField</tt><big>(</big><em>name</em>, <em>ff</em><big>)</big><a class="reference internal" href="_modules/quickff/reference.html#YaffForceField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.reference.YaffForceField" title="Permalink to this definition">¶</a></dt>
<dd><p>A model object based on a YAFF force field. Such a model can be used
to account for non-covalent interactions or residual covalent
interactions.</p>
</dd></dl>

<dl class="function">
<dt id="quickff.reference.get_ei_ff">
<tt class="descclassname">quickff.reference.</tt><tt class="descname">get_ei_ff</tt><big>(</big><em>name, system, charges, scales, radii=None, average=True, pbc=[0, 0, 0]</em><big>)</big><a class="reference internal" href="_modules/quickff/reference.html#get_ei_ff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.reference.get_ei_ff" title="Permalink to this definition">¶</a></dt>
<dd><p>A routine to construct a Yaff force field for the electrostatics</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>name</dt>
<dd>A string for the name of the force field. This name will show in
possible plots visualizing contributions along perturbation
trajectories</dd>
<dt>system</dt>
<dd>A Yaff System instance representing the system</dd>
<dt>charges</dt>
<dd>A numpy array containing the charge of each separate atom</dd>
<dt>scales</dt>
<dd>A list of 4 floats, representing scale1, scale2, scale3, scale4,
i.e. the electrostatic scaling factors</dd>
</dl>
<p><strong>Optional Arguments</strong></p>
<dl class="docutils">
<dt>radii</dt>
<dd>A numpy array containing the gaussian radii of each separate atom.
If this argument is omitted, point charges are used.</dd>
<dt>average</dt>
<dd>If set to True, the charges and radii will first be averaged over
atom types. This is True by default.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-quickff.tools">
<span id="quickff-tools-various-convenient-tools"></span><span id="seclab-rg-modules-tools"></span><h1>6. <tt class="docutils literal"><span class="pre">quickff.tools</span></tt> &#8211; Various convenient tools<a class="headerlink" href="#module-quickff.tools" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="quickff.tools.global_translation">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">global_translation</tt><big>(</big><em>coords</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#global_translation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.global_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to generate vectors that represent global translations
of a system.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>coords</dt>
<dd>a (N,3) numpy array describing the system that has to be translated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="quickff.tools.global_rotation">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">global_rotation</tt><big>(</big><em>coords</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#global_rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.global_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to generate vectors that represent global translations
of a system. Rx is a matrix of rotatino around the x-axis minus
the identity matrix. VRx is a vector of rotation around x-axis.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>coords</dt>
<dd>a (N,3) numpy array describing the system that has to be translated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="quickff.tools.fitpar">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">fitpar</tt><big>(</big><em>xs</em>, <em>ys</em>, <em>rcond=-1</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#fitpar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.fitpar" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a parabola to the samples (xs, ys):</p>
<blockquote>
<div>ys[:] = a*xs[:]^2 + b*xs[:] + c</div></blockquote>
<p>Returns the parabola parameters a, b and c.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>xs</dt>
<dd>a (N) numpy array containing the x values of the samples</dd>
<dt>ys</dt>
<dd>a (N) numpy array containing the x values of the samples</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="quickff.tools.boxqp">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">boxqp</tt><big>(</big><em>A</em>, <em>B</em>, <em>bndl</em>, <em>bndu</em>, <em>x0</em>, <em>threshold=1e-09</em>, <em>status=False</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#boxqp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.boxqp" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimize the function</p>
<blockquote>
<div>1/2*xT.A.x - B.x</div></blockquote>
<p>subject to</p>
<blockquote>
<div>bndl &lt; x &lt; bndu (element-wise)</div></blockquote>
<p>This minimization is performed using a projected gradient method with
step lengths computed using the Barzilai-Borwein method.
See 10.1007/s00211-004-0569-y for a description.</p>
<dl class="docutils">
<dt><strong>Arguments</strong></dt>
<dd>A       (n x n) NumPy array appearing in cost function
B       (n) NumPy array appearing in cost function
bndl    (n) NumPy array giving lower boundaries for the variables
bndu    (n) NumPy array giving upper boundaries for the variables
x0      (n) NumPy array providing an initial guess</dd>
<dt><strong>Optional Arguments</strong></dt>
<dd>threshold   Criterion to consider the iterations converged
status      Return also the number of iterations performed</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="quickff.tools.guess_ffatypes">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">guess_ffatypes</tt><big>(</big><em>system</em>, <em>level</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#guess_ffatypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.guess_ffatypes" title="Permalink to this definition">¶</a></dt>
<dd><p>A method to guess atom types. This will overwrite ffatypes
that are already defined in the system.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>A yaff system instance</dd>
<dt>level</dt>
<dd><p class="first">A string used for guessing atom types:</p>
<blockquote class="last">
<div><ul class="simple">
<li>low:     based on atomic number</li>
<li>medium:  based on atomic number and number of neighbors</li>
<li>high:    based on atomic number, number of neighbors and atomic number of neighbors</li>
<li>highest: based on index in the molecule</li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="quickff.tools.term_sort_atypes">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">term_sort_atypes</tt><big>(</big><em>ffatypes</em>, <em>indexes</em>, <em>kind</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#term_sort_atypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.term_sort_atypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to sort the atoms defined in indexes to give consistent term
names. This routine returns the sorted atom indexes as well as the
corresponding atom types.</p>
</dd></dl>

<dl class="function">
<dt id="quickff.tools.get_multiplicity">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">get_multiplicity</tt><big>(</big><em>n1</em>, <em>n2</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#get_multiplicity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.get_multiplicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to estimate m from local topology</p>
</dd></dl>

<dl class="function">
<dt id="quickff.tools.get_restvalue">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">get_restvalue</tt><big>(</big><em>values</em>, <em>m</em>, <em>thresshold=0.3490658503988659</em>, <em>mode=1</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#get_restvalue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.get_restvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a rest value of 0.0, 360/(2*m) or None depending on the given
equilbrium values.</p>
<p>For mode=0, the rest value is:</p>
<blockquote>
<div><p>0, if all &#8216;values modulo per&#8217; are in the interval
[0,thresshold] U [per-thresshold,per]</p>
<p>per/2, if all &#8216;values modulo per&#8217; are in the interval
[per/2-thresshold,per/2+thresshold]</p>
<p>None, in all other cases</p>
</div></blockquote>
<p>For mode=1, the rest value is determined as follows:</p>
<blockquote>
<div>first the values are folded in the interval [0,per/2] by first
taking the module with per and then mirroring values in [per/2,per]
on [0,per/2]. Next, the mean and std of the folded values are
computed. If the std is larger then the thresshold, the values are
considered to be too scattered and no rest value can be computed
(None is returned). If the std is small enough, the rest value will
be determined based on the mean. If the mean is close enough to 0,
the rest value will be 0. If the mean is close enough to per/2, the
rest value will be per/2. In all other cases no rest value will be
computed and None is returned.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="quickff.tools.get_ei_radii">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">get_ei_radii</tt><big>(</big><em>numbers</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#get_ei_radii"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.get_ei_radii" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to return atomic radii for use in the Gaussian charge
distribution. These radii are computed according to the procedure of
Chen and Slater:</p>
<p>First the Slater exponent is computed from the hardness using the
formula of Rappe and Goddard (hardness of Pearson and Parr is used)</p>
<p>Next the gaussian exponent alpha is fitted by minimizing the
L2-difference between the between the homonuclear Coulomb integral over
Slater orbitals and over Gaussian orbitals.</p>
</dd></dl>

<dl class="function">
<dt id="quickff.tools.digits">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">digits</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#digits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.digits" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a string representation of x with exactly n digits if possible.</p>
</dd></dl>

<dl class="function">
<dt id="quickff.tools.average">
<tt class="descclassname">quickff.tools.</tt><tt class="descname">average</tt><big>(</big><em>data</em>, <em>ffatypes</em>, <em>fmt='full'</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="_modules/quickff/tools.html#average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.tools.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Average the atomic parameters stored in data over atoms of the same atom
type.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>data</dt>
<dd>a list or numpy array containing the data</dd>
<dt>ffatypes</dt>
<dd>a listor numpy array containing the atom types. Should have equal
length as data</dd>
</dl>
<p><strong>Keywork arguments</strong></p>
<dl class="docutils">
<dt>fmt</dt>
<dd><p class="first">Should be either full, dict or sort. In case of full, the result will be
returned as an numpy array of equal length as data and ffatypes. In
case of dict, the result will be returned as a dictionairy of the
following format:</p>
<blockquote>
<div>{ffatype0: value0, ffatype1: value1, ...}</div></blockquote>
<p>in which value0, ... is the mean value of the given ffatype. In case
of sort, a dictionairy of the following format will be returned:</p>
<blockquote>
<div>{ffatype0: values0, ffatype1: values1, ...}</div></blockquote>
<p class="last">in which values0, ... is a list of the values for the given ffatype.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-quickff.valence">
<span id="quickff-valence-valenceff-class-storing-all-valence-ff-terms"></span><h1>7. <tt class="docutils literal"><span class="pre">quickff.valence</span></tt> &#8211; ValenceFF class storing all valence ff terms<a class="headerlink" href="#module-quickff.valence" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="quickff.valence.ValenceFF">
<em class="property">class </em><tt class="descclassname">quickff.valence.</tt><tt class="descname">ValenceFF</tt><big>(</big><em>system</em>, <em>specs=None</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to collect all valence terms in the force field for which
parameters need to be estimated.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>an instance of the Yaff System class containing all system
properties</dd>
</dl>
<p><strong>Keyword Arguments</strong></p>
<dl class="docutils">
<dt>specs</dt>
<dd>Not yet implemented</dd>
</dl>
<dl class="method">
<dt id="quickff.valence.ValenceFF.add_term">
<tt class="descname">add_term</tt><big>(</big><em>pot</em>, <em>ics</em>, <em>atypes</em>, <em>tasks</em>, <em>units</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.add_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.add_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds new term both to the Yaff vlist object and a new QuickFF
list (self.terms) which holds all information about the term
for easy access later in QuickFF.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>pot</dt>
<dd>an instance of ValenceTerm from <cite>yaff.pes.vlist.py</cite> representing
the potential chosen for the term</dd>
<dt>ics</dt>
<dd>list of InternalCoordinate instances from <cite>yaff.pes.iclist.py</cite></dd>
<dt>atypes</dt>
<dd>ordered string of atom types (required to assign name to the
term)</dd>
<dt>tasks</dt>
<dd>List of strings defining all tasks that have to be performed for
this term. Possible tasks are: PT_ALL, HC_FC_DIAG, HC_FC_CROSS,
EQ_RV.</dd>
<dt>units</dt>
<dd>Units for all parameters in this term (ordered in the same
way as parameters are stored in <cite>yaff.vlist.vtab</cite>)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.apply_constraints">
<tt class="descname">apply_constraints</tt><big>(</big><em>constraints</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.apply_constraints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.apply_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to apply equality constraints in the force field fitting</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>contraints</dt>
<dd>A dictionairy containing (master: slaves) definitions in which
master is a string defining the master basename and slaves is a
list of strings defining the slave basenames.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.check_params">
<tt class="descname">check_params</tt><big>(</big><em>term</em>, <em>labels</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.check_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.check_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the given term has all given pars defined in
labels.</p>
<p><strong>Arguments</strong></p>
<dl class="docutils">
<dt>term</dt>
<dd>An instance of the Term class defining the term that has to be
checked</dd>
<dt>labels</dt>
<dd>A list of strings defining which parameters should be checked.
only arguments of the <cite>only</cite> option of Valence.get_params
are allowed.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.get_hessian_contrib">
<tt class="descname">get_hessian_contrib</tt><big>(</big><em>index</em>, <em>fc=None</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.get_hessian_contrib"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.get_hessian_contrib" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the contribution to the covalent hessian of term with given
index (and its slaves). If fc is given, set the fc of the master
and its slave to the given fc.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.init_bend_terms">
<tt class="descname">init_bend_terms</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.init_bend_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.init_bend_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize all bend terms in the system based on the bends attribute
of the system instance. All bend terms are given harmonic
potentials.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.init_bond_terms">
<tt class="descname">init_bond_terms</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.init_bond_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.init_bond_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize all bond terms in the system based on the bonds attribute
of the system instance. All bond terms are given harmonic
potentials.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.init_cross_terms">
<tt class="descname">init_cross_terms</tt><big>(</big><em>specs=None</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.init_cross_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.init_cross_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize cross terms between bonds and bends.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.init_dihedral_terms">
<tt class="descname">init_dihedral_terms</tt><big>(</big><em>thresshold=0.3490658503988659</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.init_dihedral_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.init_dihedral_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the dihedral potentials from the local topology. The
dihedral potential will be one of the two following possibilities:</p>
<blockquote>
<div><p>The multiplicity m is determined from the local topology, i.e.
the number of neighbors of the central two atoms in the dihedral</p>
<p>If the equilibrium value of all instances of the torsion are
within <cite>thresshold</cite> of 0 deg or per/2 with per = 180deg/m,
the following potential will be chosen:</p>
<blockquote>
<div>0.5*K*(1-cos(m*psi-m*psi0)) with psi0 = 0 or 360/(2*m)</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.init_oop_terms">
<tt class="descname">init_oop_terms</tt><big>(</big><em>thresshold_zero=0.09448630669606262</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.init_oop_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.init_oop_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize all out-of-plane terms in the system based on the oops
attribute of the system instance. All oops are given harmonic
potentials.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.is_negligible">
<tt class="descname">is_negligible</tt><big>(</big><em>term_index</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.is_negligible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.is_negligible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the given term can be neglected (e.g. in parameter files).</p>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.iter_masters">
<tt class="descname">iter_masters</tt><big>(</big><em>label=None</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.iter_masters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.iter_masters" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all master terms in the valence force field. If label
is given, only iterate of the terms with the label in its name.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.iter_terms">
<tt class="descname">iter_terms</tt><big>(</big><em>label=None</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.iter_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.iter_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all terms in the valence force field. If label is
given, only iterate over terms with the label its name.</p>
</dd></dl>

<dl class="method">
<dt id="quickff.valence.ValenceFF.modify_term">
<tt class="descname">modify_term</tt><big>(</big><em>term_index</em>, <em>pot</em>, <em>ics</em>, <em>basename</em>, <em>tasks</em>, <em>units</em><big>)</big><a class="reference internal" href="_modules/quickff/valence.html#ValenceFF.modify_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quickff.valence.ValenceFF.modify_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify the term with given index to a new valence term.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. <tt class="docutils literal"><span class="pre">quickff.cost</span></tt> &#8211; Least-Square cost function for hessian matching</a></li>
<li><a class="reference internal" href="#module-quickff.io">2. <tt class="docutils literal"><span class="pre">quickff.io</span></tt> &#8211; Input/Ouput methods</a></li>
<li><a class="reference internal" href="#module-quickff.perturbation">3. <tt class="docutils literal"><span class="pre">quickff.perturbation</span></tt> &#8211; Perturbation trajectories for internal coordinates</a></li>
<li><a class="reference internal" href="#module-quickff.program">4. <tt class="docutils literal"><span class="pre">quickff.program</span></tt> &#8211; Program classes implementing a sequence of fitting steps</a></li>
<li><a class="reference internal" href="#module-quickff.reference">5. <tt class="docutils literal"><span class="pre">quickff.reference</span></tt> &#8211; Representation of the ab initio reference data</a></li>
<li><a class="reference internal" href="#module-quickff.tools">6. <tt class="docutils literal"><span class="pre">quickff.tools</span></tt> &#8211; Various convenient tools</a></li>
<li><a class="reference internal" href="#module-quickff.valence">7. <tt class="docutils literal"><span class="pre">quickff.valence</span></tt> &#8211; ValenceFF class storing all valence ff terms</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tu_biphenyl.html"
                        title="previous chapter">Tutorial 3 - Biphenyl</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="rg_scripts.html"
                        title="next chapter">1. <tt class="docutils literal"><span class="pre">qff.py</span></tt> &#8211; Main script to run QuickFF calculation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/rg_module.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="rg_scripts.html" title="1. qff.py – Main script to run QuickFF calculation"
             >next</a> |</li>
        <li class="right" >
          <a href="tu_biphenyl.html" title="Tutorial 3 - Biphenyl"
             >previous</a> |</li>
        <li><a href="index.html">QuickFF 2.1.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2016, Louis Vanduyfhuys.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>